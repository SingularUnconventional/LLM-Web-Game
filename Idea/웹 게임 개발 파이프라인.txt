### **웹 게임 개발 파이프라인 (LLM 게임)**

---

**단계 1: 프로젝트 초기 설정 및 기본 환경 구축**

* **목표:** 개발 환경을 설정하고, 모든 개발자가 일관된 환경에서 작업할 수 있도록 기본 틀을 마련합니다.
* **세부 작업:**
    1.  **프로젝트 초기화:** `package.json` 생성 및 기본 개발 의존성 설치 (Node.js, npm/yarn).
    2.  **폴더 구조 생성:** 위에서 제시된 최종적인 폴더 구조를 생성합니다. (`public`, `src`, `server`, `.env` 등)
    3.  **Git 초기화 및 `.gitignore` 설정:** 버전 관리를 시작하고, 불필요한 파일(`node_modules`, `.env` 등)이 커밋되지 않도록 합니다.
    4.  **기본 웹 서버 설정 (Express):** `server/app.js`에 Express 서버의 기본 설정(CORS, JSON 파서)을 추가하고, `/api` 엔드포인트에 대한 기본 라우팅을 구성하여 서버가 정상적으로 동작하는지 확인합니다.
    5.  **기본 프론트엔드 설정 (React/Vue/Vanilla JS):** `public/index.html`과 `src/main.js`를 연결하고, 간단한 "Hello, World!" 메시지를 표시하여 프론트엔드가 정상적으로 렌더링되는지 확인합니다. 개발 서버(Webpack Dev Server, Vite 등)를 설정합니다.

---

**단계 2: 백엔드 핵심 - Gemini API 연동 및 캐릭터/이미지 생성 로직**

* **목표:** 게임의 가장 핵심적인 기능인 심리 테스트 기반의 캐릭터 동적 생성, 이미지 생성, 그리고 채팅 응답 기능을 백엔드에서 구현합니다.
* **세부 작업:**
    1.  **`.env` 및 `server/config/gemini.js` 설정:** Gemini API 키를 `.env`에 등록하고, `gemini.js`에서 이를 불러와 Gemini API 클라이언트를 초기화하는 기본 설정을 합니다.
    2.  **`server/services/geminiService.js` 기본 구조 구현:**
        * Gemini API 클라이언트 인스턴스 생성.
        * **`generateCharacterPersonaAndImage` 함수 스텁 구현:** 사용자의 심리 테스트 결과를 받아 Gemini에게 캐릭터 페르소나 생성 및 `image_generation` 툴을 호출하는 기본 틀을 잡습니다. (아직 구체적인 프롬프트는 제외)
        * **`generateChatResponse` 함수 스텁 구현:** 대화 이력과 사용자 메시지를 받아 Gemini에게 채팅 응답을 요청하는 기본 틀을 잡습니다.
    3.  **`server/data/characterTemplates.json` 정의:** Gemini가 캐릭터를 생성할 때 참조할 캐릭터 템플릿(예: `"name": "이름", "appearance_description": "외형 묘사", "core_concern": "핵심 고민", "personality_traits": []` 등)을 구조화하여 정의합니다.
    4.  **`server/routes/psychology.js` 및 `server/controllers/psychologyController.js` 구현 (캐릭터 생성):**
        * `/api/psychology/complete` 라우트 정의: 클라이언트로부터 심리 테스트 결과를 받는 POST 엔드포인트.
        * `psychologyController.js`에서 이 요청을 받아 `geminiService.generateCharacterPersonaAndImage`를 호출하고, 결과를 반환하는 로직을 구현합니다.
        * **(`image_generation` 툴 연동):** `geminiService.js` 내에서 `image_generation` 툴을 사용하여 캐릭터 외형 묘사를 바탕으로 이미지를 생성하고, 생성된 이미지의 `content_id`를 받도록 구현합니다.
    5.  **`server/routes/chat.js` 및 `server/controllers/chatController.js` 구현 (채팅 응답):**
        * `/api/chat/send` 라우트 정의: 클라이언트로부터 사용자 메시지를 받는 POST 엔드포인트.
        * `chatController.js`에서 이 요청을 받아 `geminiService.generateChatResponse`를 호출하고, 캐릭터의 응답을 반환하는 로직을 구현합니다.
    6.  **데이터베이스 연동 (MongoDB + Mongoose 예시):**
        * `server/config/db.js`에 MongoDB 연결 설정 추가.
        * `server/models/User.js` 및 `server/models/GameSession.js` 모델 정의:
            * `GameSession` 모델에 `characterPersona` (생성된 캐릭터 페르소나 JSON), `characterImageContentId` (생성된 이미지 ID), `dialogueHistory` 등을 저장할 필드 추가.
        * 캐릭터 생성 후 `GameSession`에 데이터를 저장하고, 채팅 메시지 수신 시 `dialogueHistory`를 업데이트하는 로직을 추가합니다.
    7.  **`server/routes/images.js` 및 `server/controllers/imageController.js` 구현:**
        * `/api/images/:contentId` 라우트를 정의하여 `image_generation` 툴로 생성된 이미지를 클라이언트에게 서빙하는 엔드포인트를 구현합니다. (보안 및 캐싱 고려)

---

**단계 3: 프론트엔드 UI/UX 구현 및 백엔드 연동**

* **목표:** 사용자가 게임을 플레이할 수 있도록 필요한 모든 UI 화면을 구현하고, 백엔드 API와 완벽하게 연동합니다.
* **세부 작업:**
    1.  **`src/pages/HomePage.js` 및 `src/components/StartScreen/` 구현:**
        * 시작 화면의 UI/UX (텍스트, 버튼, 배경) 구현.
        * '시작하기' 버튼 클릭 시 `PsychologyTestPage`로 이동하는 라우팅 설정.
    2.  **`src/pages/PsychologyTestPage.js` 및 `src/components/PsychologyTest/` 구현:**
        * 심리 테스트 질문 및 선택지 UI 렌더링.
        * 사용자 선택을 수집하고, 테스트 완료 시 `src/utils/api.js`를 통해 `/api/psychology/complete` 백엔드 API로 결과 전송.
        * 로딩 스피너 (`src/components/common/LoadingSpinner.js`) 구현 및 백엔드 응답 대기 시 표시.
    3.  **`src/pages/GamePlayPage.js` 구현:**
        * **캐릭터 동적 표시:** 백엔드에서 받은 `characterPersona`와 `characterImageContentId`를 바탕으로 `src/components/CharacterDisplay/` 컴포넌트를 사용하여 캐릭터 이미지와 이름을 표시.
        * **`src/components/ChatInterface/` 구현:**
            * 메시지 버블 렌더링 (캐릭터/플레이어).
            * 메시지 입력 영역 (텍스트 입력 필드 또는 선택지 버튼) 구현.
            * 타이핑 효과, 메시지 전송 딜레이 등 자연스러운 메신저 흐름 구현 (`src/utils/textEffects.js` 활용).
            * 사용자 메시지 전송 시 `src/utils/api.js`를 통해 `/api/chat/send` 백엔드 API로 전송.
            * 백엔드로부터 캐릭터 응답을 받아 채팅창에 표시.
    4.  **`src/components/EmotionLog.js` 및 `src/pages/EmotionLogPage.js` 구현:**
        * 간단한 감정 로그 표시 UI 구현. (추후 감정 조각 수집 시 연동)
    5.  **전역 상태 관리 (`src/contexts/GameContext.js`, `src/contexts/UserContext.js`):**
        * 게임 진행 상태(현재 캐릭터, 대화 이력, 감정 변화 등) 및 사용자 데이터를 관리하도록 설정.
        * 심리 테스트 완료 후 생성된 캐릭터 정보, 게임 세션 정보를 전역 상태에 저장하고 필요한 컴포넌트에서 활용.
    6.  **스타일링 (`src/styles/`):**
        * 모바일 우선 반응형 디자인을 고려하여 각 컴포넌트의 스타일(`*.module.css` 또는 Sass)을 적용합니다.
        * 애니메이션, 전환 효과 등을 추가하여 UI/UX를 개선합니다.

---

**단계 4: 게임 로직 상세 구현 및 감정 시스템 연동**

* **목표:** 기획서에 명시된 '낮/밤 루프', '감정 반응 시스템', '감정 조각 수집' 등 게임의 핵심 로직을 완성하고 UI와 연동합니다.
* **세부 작업:**
    1.  **`server/services/geminiService.js` 상세화 (프롬프트 엔지니어링):**
        * 캐릭터 페르소나 생성 시: 심리 테스트 결과와 `characterTemplates.json`을 바탕으로 Gemini가 실제 캐릭터 속성(이름, 성격, 고민)을 생성하도록 프롬프트 상세화.
        * 채팅 응답 생성 시:
            * 캐릭터의 현재 감정 상태, 이전 대화 맥락, 핵심 고민을 프롬프트에 포함하여 Gemini가 캐릭터의 말투, 문장 길이, 이모티콘 사용 여부를 조절하여 응답하도록 유도.
            * `게임 기획.txt`의 "감정 반응 시스템" (캐릭터 감정 색 변화, 말투/문장 길이/이모티콘 사용)을 Gemini 프롬프트에 반영.
    2.  **`server/services/gameService.js` 구현:**
        * **낮/밤 루프 관리:** 특정 시간 또는 특정 대화량 도달 시 '밤' 세션으로 전환되는 로직.
        * **감정 조각 생성 조건:** 플레이어의 특정 감정 반응 또는 특정 키워드 언급 시 '감정 조각' 생성을 트리거하는 로직.
        * 캐릭터의 감정 진척도(예: 불안 → 차분)를 업데이트하고, 이 상태를 `GameSession`에 저장.
    3.  **프론트엔드 `GamePlayPage` 업데이트:**
        * 캐릭터의 감정 변화에 따른 UI 피드백 (간접적인 색상 변화, 표정 변화 등).
        * '감정 조각' 생성 예고 시 시각/음향 연출 구현 (`src/public/assets/audio`, `src/public/assets/images` 활용).
        * 밤 세션 진입 시 UI 변경 및 `EmotionLog` 컴포넌트 활성화.
    4.  **`src/pages/EndingPage.js` 및 `src/components/PersonaDisplay.js` 구현:**
        * 모든 감정 조각 수집 또는 특정 조건 충족 시 엔딩 페이지로 전환.
        * 수집한 감정 조각들과 완성된 '상징적 자아(페르소나)'를 시각적으로 보여주는 UI 구현.

---

**단계 5: 테스트 및 배포 준비**

* **목표:** 구현된 모든 기능이 정상적으로 작동하는지 확인하고, 실제 서비스 가능한 형태로 배포를 준비합니다.
* **세부 작업:**
    1.  **단위 테스트 및 통합 테스트:**
        * 백엔드 API 엔드포인트 및 컨트롤러, 서비스 로직에 대한 테스트 코드 작성 및 실행.
        * 프론트엔드 컴포넌트 및 유틸리티 함수에 대한 테스트 코드 작성 및 실행.
    2.  **보안 강화:**
        * API 호출 시 인증/인가 (JWT 등) 적용 (필요 시).
        * 데이터 유효성 검사 (서버/클라이언트 모두).
        * API Rate Limiting 적용.
    3.  **성능 최적화:**
        * 프론트엔드 번들 크기 최적화 (코드 스플리팅, 이미지 최적화).
        * 백엔드 API 응답 속도 및 데이터베이스 쿼리 최적화.
    4.  **배포 자동화 (CI/CD):** (선택 사항) GitHub Actions, Jenkins 등을 사용하여 개발-테스트-배포 프로세스 자동화.
    5.  **배포:** 실제 서버(AWS EC2, Vercel, Netlify 등)에 게임을 배포합니다.

---